<!DOCTYPE html>
<html prefix="og: https://ogp.me/ns#" class="mdui-theme-auto" data-theme="auto">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="keywords" content="">
  <meta name="description" content="">
  <meta name="author" content="Eagle233">
  <meta name="generator" content="Hexo 7.3.0">
    <meta name="description" content="基础 标识符可见性在Go语言中，标识符（变量、函数、类型等）的首字母大写表示它可以被其他包访问和使用（已导出），而首字母小写则表示它只能在当前包内部使用（未导出）。(private&#x2F;public)  命名返回值Go语言的命名返回值允许在函数声明中指定返回变量名，这些变量在函数体内可直接赋值，并在使用裸返回（return）时自动返回其当前值，从而简化代码，但需注意避免降低可读性。 pack">
<meta property="og:type" content="article">
<meta property="og:title" content="[Language] Golang 核心概念总结">
<meta property="og:url" content="https://blog.eagle233.top/2025/07/28/Language/Language-Golang-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Eagle233-Blog">
<meta property="og:description" content="基础 标识符可见性在Go语言中，标识符（变量、函数、类型等）的首字母大写表示它可以被其他包访问和使用（已导出），而首字母小写则表示它只能在当前包内部使用（未导出）。(private&#x2F;public)  命名返回值Go语言的命名返回值允许在函数声明中指定返回变量名，这些变量在函数体内可直接赋值，并在使用裸返回（return）时自动返回其当前值，从而简化代码，但需注意避免降低可读性。 pack">
<meta property="og:locale">
<meta property="article:published_time" content="2025-07-27T19:43:34.000Z">
<meta property="article:modified_time" content="2025-07-27T20:11:14.478Z">
<meta property="article:author" content="Eagle233">
<meta name="twitter:card" content="summary">
      <link rel="icon" href="">
      <title>
        
          [Language] Golang 核心概念总结 - Eagle233-Blog
              
      </title>
      
<link rel="stylesheet" href="/css/site.css">

      
<link rel="stylesheet" href="/css/mdui_2.0.3/mdui.css">

      <style>
        /*禁用mdui对code的样式，因为它干扰了prism.js*/
        .mdui-prose pre code {
          background-color: transparent;
          padding: 0px 0px;
        }
      </style>
      
<script src="/css/mdui_2.0.3/mdui.global.js"></script>

      
<script src="/fancybox/fancybox.umd.js"></script>

      
<link rel="stylesheet" href="/fancybox/fancybox.css">

      
<script src="/carousel/carousel.umd.js"></script>

      
<link rel="stylesheet" href="/carousel/carousel.css">

      
<link rel="stylesheet" href="/css/prism.css">

          
<link rel="stylesheet" href="/css/katex.min.css">

            
<link rel="stylesheet" href="/css/font-material-icon-filled/MaterialIconFilled.css">

              <!-- Filled -->
              <script>window.$=mdui.$</script>
</head>

  <body class="line-numbers">
    <mdui-layout>
      <mdui-top-app-bar>
        <mdui-button-icon icon="menu" id="menu-btn">
        </mdui-button-icon>
        <mdui-top-app-bar-title>
          Eagle233-Blog
        </mdui-top-app-bar-title>
        <div style="flex-grow: 1"></div>
        <mdui-button-icon icon="search" id="search-dlg-btn"></mdui-button-icon>
          
      </mdui-top-app-bar>
      <mdui-navigation-drawer close-on-overlay-click close-on-esc id="drawer">
    <mdui-list>
        
            
            <mdui-list-item rounded icon="home"
                href="/"
                
                
                rel="next">
                Home
            </mdui-list-item>
            
            
            
            <mdui-list-item rounded icon="folder"
                href="/categories"
                
                
                rel="next">
                Categories
            </mdui-list-item>
            
            
            
            <mdui-list-item rounded icon="bookmark"
                href="/tags"
                
                
                rel="next">
                Tags
            </mdui-list-item>
            
            
            
            <mdui-list-item rounded icon="archive"
                href="/archives"
                
                
                rel="next">
                Archives
            </mdui-list-item>
            
            
            
            <mdui-list-item rounded icon="info"
                href="/about"
                
                
                rel="next">
                About
            </mdui-list-item>
            
            
    </mdui-list>
</mdui-navigation-drawer>
        <mdui-layout-main style="min-height: 800px;" id="main">
          <div style="padding-left: 16px;padding-right: 16px;" id="content">
            <mdui-card variant="filled" style="padding: 16px;width: 100%;">
  <div class="mdui-prose post" id="post-all">
    <h1 style="margin-bottom: 8px;">
      [Language] Golang 核心概念总结
    </h1>
    <span class="post-date">
      <mdui-icon name="date_range" style="vertical-align: text-bottom;font-size: 18px;"></mdui-icon>
      2025-07-28 03:43:34 &nbsp; <mdui-icon name="update"
          style="vertical-align: text-bottom;font-size: 18px;"></mdui-icon>
        2025-07-28 04:11:14
    </span>
    <br>
    <span>
        Categories
          
            <!-- <mdui-chip href="/categories/Language/" variant="filter" style="vertical-align: middle;">
                          Language
                      </mdui-chip> -->
            <a href="/categories/Language/">
              Language
            </a>
            
              <br>
      </span>
      
        
          Tags
            
                
                  <!-- photos gallery -->
                  
                      <!-- content -->
                      <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol>
<li><p><strong>标识符可见性</strong><br>在Go语言中，标识符（变量、函数、类型等）的首字母大写表示它可以被其他包访问和使用（已导出），而首字母小写则表示它只能在当前包内部使用（未导出）。(private&#x2F;public)</p>
</li>
<li><p><strong>命名返回值</strong><br>Go语言的命名返回值允许在函数声明中指定返回变量名，这些变量在函数体内可直接赋值，并在使用裸返回（<code>return</code>）时自动返回其当前值，从而简化代码，但需注意避免降低可读性。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">package main

import &quot;fmt&quot;

func addAndSubtract(a, b int) (sum, diff int) &#123;
    sum &#x3D; a + b
    diff &#x3D; a - b
    return &#x2F;&#x2F; 裸返回:自动返回当前 sum 和 diff 的值
&#125;

func main() &#123;
    total, difference :&#x3D; addAndSubtract(10, 5)
    fmt.Printf(&quot;和是:%d,差是:%d\n&quot;, total, difference)
    &#x2F;&#x2F; 输出: 和是:15,差是:5
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>声明的理解方式</strong></p>
<ul>
<li><p><strong>函数声明</strong></p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">func add(x, y int) int &#123;
    return x + y
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>一个函数的函数名叫做<code>add</code>，传入了<code>x</code>和<code>y</code>，数据类型是<code>int</code>，返回 <code>int</code> 类型数据。</p>
</li>
<li><p><strong>变量声明</strong></p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">var age int &#x3D; 30<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>一个变量名为 <code>age</code>，数据类型是<code>int</code>，赋值为<code>30</code>。</p>
</li>
</ul>
</li>
<li><p><strong><code>fmt.Printf</code> 格式化动词</strong></p>
<ul>
<li><p><code>%v</code>：打印值的默认表示。</p>
</li>
<li><p><code>%T</code>：打印值的类型。</p>
</li>
<li><p><code>%#v</code>：打印值的Go语言语法表示。</p>
</li>
</ul>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; 假设你有一个 Product 结构体实例p:
&#x2F;&#x2F; type Product struct &#123; ID int; Name string; Price float64 &#125;
&#x2F;&#x2F; p :&#x3D; Product&#123;ID:101, Name: &quot;Go T-shirt&quot;, Price:25.99&#125;

&#x2F;&#x2F; fmt.Printf(&quot;使用%%v打印:%v\n&quot;,p)
&#x2F;&#x2F; 输出:使用%v打印:(101 Go T-shirt 25.99)

&#x2F;&#x2F; fmt.Printf(&quot;使用%%#v打印:%#v\n&quot;,p)
&#x2F;&#x2F; 输出: 使用%#v打印:main.Product&#123;ID:101, Name: &quot;Go T-shirt&quot;, Price:25.99&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>变量零值</strong><br>没有明确初始化的变量声明会被赋予对应类型的零值。</p>
</li>
<li><p><strong>类型转换</strong><br>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。Go在不同类型的项之间赋值时需要显式转换。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">var f float64 &#x3D; math.Sqrt(float64(x*x + y*y))
var z uint &#x3D; uint(f)
z &#x3D; f &#x2F;&#x2F; 错误!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>常量声明</strong><br>常量的声明与变量类似，只不过使用 <code>const</code> 关键字。常量不能用 <code>:=</code> 语法声明。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">const World &#x3D; &quot;世界&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>数值常量</strong><br>数值常量是高精度的值。一个未指定类型的常量由上下文来决定其类型。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">const Pi &#x3D; 3.14159265358979323846 &#x2F;&#x2F; 这是一个高精度的无类型浮点常量

var f float32 &#x3D; Pi &#x2F;&#x2F; Pi 会被转换为 float32,精度会损失
var d float64 &#x3D; Pi &#x2F;&#x2F; Pi 会被转换为 float64,精度保留更多
fmt.Println(f)     &#x2F;&#x2F; 3.1415927
fmt.Println(d)     &#x2F;&#x2F; 3.141592653589793

const BigInt &#x3D; 1000000000000000000 &#x2F;&#x2F; 这是一个无类型整数常量,非常大

&#x2F;&#x2F; var i int &#x3D; BigInt &#x2F;&#x2F; 错误! BigInt太大,int无法容纳,编译报错
var i64 int64 &#x3D; BigInt &#x2F;&#x2F; 正确! BigInt 被赋值给 int64,它能容纳这么大的值
fmt.Println(i64)

&#x2F;&#x2F; 在表达式中
fmt.Println(BigInt + 1)   &#x2F;&#x2F; BigInt 仍然是无类型常量,计算结果仍然是高精度的无类型常量
fmt.Println(BigInt &#x2F; 2.0) &#x2F;&#x2F; BigInt 会被视为浮点数,因为2.0 是浮点数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong><code>for</code> 循环</strong><br>C语言的 <code>while</code> 在Go中叫做 <code>for</code>。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">for sum &lt; 1000 &#123;
    sum +&#x3D; sum
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>无限循环</strong></p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">for &#123;
    &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong><code>if</code> 语句中的简短语句</strong><br>和 <code>for</code> 一样，<code>if</code> 语句可以在条件表达式前执行一个简短语句。该语句声明的变量作用域仅在 <code>if</code> 之内。在 <code>if</code> 的简短语句中声明的变量同样可以在对应的任何 <code>else</code> 块中使用。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">func pow(x, n, lim float64) float64 &#123;
    if v :&#x3D; math.Pow(x, n); v &lt; lim &#123;
        return v
    &#125;
    return lim
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong><code>switch</code> 语句</strong><br>Go的做法相当于这些语言中为每个 <code>case</code> 后面自动添加了所需的 <code>break</code> 语句。在Go中，除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。Go的另一点重要的不同在于 <code>switch</code> 的 <code>case</code> 无需为常量，且取值不限于整数。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">switch os :&#x3D; runtime.GOOS; os &#123;
case &quot;darwin&quot;:
    fmt.Println(&quot;macOS.&quot;)
case &quot;linux&quot;:
    fmt.Println(&quot;Linux.&quot;)
default:
    &#x2F;&#x2F; freebsd, openbsd,
    &#x2F;&#x2F; plang, windows...
    fmt.Printf(&quot;%s.\n&quot;, os)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong><code>time.Now()</code></strong><br>Go练习场中，<code>time.Now()</code>是Go的生日: <code>2009-11-10 23:00:00 UTC</code>。</p>
</li>
<li><p><strong>无条件 <code>switch</code></strong><br><code>switch</code> 语句可以不带条件表达式，等价于 <code>switch true</code>。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">func main() &#123;
    t :&#x3D; time.Now()
    switch &#123;
    case t.Hour() &lt; 12:
        fmt.Println(&quot;早上好!&quot;)
    case t.Hour() &lt; 17:
        fmt.Println(&quot;下午好!&quot;)
    default:
        fmt.Println(&quot;晚上好!&quot;)
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong><code>defer</code> 语句</strong><br><code>defer</code> 语句会将函数推迟到外层函数返回之后执行。推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。推迟调用的函数调用会被压入一个栈中。当外层函数返回时，被推迟的调用会按照 FILO（后进先出）的顺序调用。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">package main

import &quot;fmt&quot;

func main() &#123;
    fmt.Println(&quot;counting&quot;)

    for i :&#x3D; 0; i &lt; 10; i++ &#123;
        defer fmt.Println(i)
    &#125;

    fmt.Println(&quot;done&quot;)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">counting
<span class="token keyword">done</span>
<span class="token number">9</span>
<span class="token number">8</span>
<span class="token number">7</span>
<span class="token number">6</span>
<span class="token number">5</span>
<span class="token number">4</span>
<span class="token number">3</span>
<span class="token number">2</span>
<span class="token number">1</span>
<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>指针</strong><br>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针，其零值为 <code>nil</code>。</p>
</li>
<li><p><strong>无指针运算</strong><br>与C不同，Go没有指针运算。</p>
</li>
<li><p><strong>结构体 (struct)</strong><br>一个结构体（<code>struct</code>）就是一组字段（<code>field</code>）。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">type Vertex struct &#123;
    X int
    Y int
&#125;

func main() &#123;
    fmt.Println(Vertex&#123;1, 2&#125;)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>结构体指针访问字段</strong><br>如果我们有一个指向结构体的指针 <code>p</code> 那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。不过这么写太啰嗦了，所以语言也允许我们使用隐式解引用，直接写 <code>p.X</code> 就可以。</p>
</li>
<li><p><strong>结构体字面量</strong><br>使用 <code>Name:</code> 语法可以仅列出部分字段（字段名的顺序无关）。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">v2 :&#x3D; Vertex&#123;X: 1&#125; &#x2F;&#x2F; Y: 被隐式地赋予零值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>数组</strong><br>类型 <code>[n]T</code> 表示一个数组，它拥有 <code>n</code> 个类型为 <code>T</code> 的值。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">var a [10]int
primes :&#x3D; [6]int&#123;2, 3, 5, 7, 11, 13&#125; &#x2F;&#x2F; 声明一个变量 primes 为6个 int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p><strong>切片 (Slice)</strong><br>切片是引用类型，它只是描述了底层数组中的一段。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">a[low:high] &#x2F;&#x2F; 左闭右开<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>切片与底层数组</strong><br>切片就像数组的引用。切片并不存储任何数据，它只是描述了底层数组中的一段。更改切片的元素会修改其底层数组中对应的元素。和它共享底层数组的切片都会观测到这些修改。</p>
</li>
<li><p><strong>切片字面量</strong><br>切片字面量 <code>[]Type&#123;...&#125;</code> 会隐式创建一个底层数组来存储数据，并返回一个引用该底层数组的切片，这与直接创建固定长度数组的数组字面量 <code>[N]Type&#123;...&#125;</code> 不同。</p>
</li>
<li><p><strong>切片默认行为</strong><br>在进行切片时，你可以利用它的默认行为来忽略上下界。切片下界的默认值为0，上界则是该切片的长度。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">var a [10]int
&#x2F;&#x2F; 以下切片表达式等价:
&#x2F;&#x2F; a[0:10]
&#x2F;&#x2F; a[:10]
&#x2F;&#x2F; a[0:]
&#x2F;&#x2F; a[:]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>切片的长度与容量</strong><br>切片的长度是其当前元素数量，而容量是从切片起点到其底层数组末尾的元素数量。切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">package main

import &quot;fmt&quot;

func main() &#123;
    s :&#x3D; []int&#123;2, 3, 5, 7, 11, 13&#125;
    printSlice(s)

    &#x2F;&#x2F; 截取切片使其长度为0
    s &#x3D; s[:0]
    printSlice(s)

    &#x2F;&#x2F; 扩展其长度
    s &#x3D; s[:4]
    printSlice(s)

    &#x2F;&#x2F; 舍弃前两个值
    s &#x3D; s[2:]
    printSlice(s)
&#125;

func printSlice(s []int) &#123;
    fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d %v\n&quot;, len(s), cap(s), s)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">len</span><span class="token operator">=</span><span class="token number">6</span> <span class="token assign-left variable">cap</span><span class="token operator">=</span><span class="token number">6</span> <span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">11</span> <span class="token number">13</span><span class="token punctuation">]</span>
<span class="token assign-left variable">len</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">cap</span><span class="token operator">=</span><span class="token number">6</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token assign-left variable">len</span><span class="token operator">=</span><span class="token number">4</span> <span class="token assign-left variable">cap</span><span class="token operator">=</span><span class="token number">6</span> <span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">7</span><span class="token punctuation">]</span>
<span class="token assign-left variable">len</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">cap</span><span class="token operator">=</span><span class="token number">4</span> <span class="token punctuation">[</span><span class="token number">5</span> <span class="token number">7</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong><code>nil</code> 切片</strong><br><code>nil</code> 切片的长度和容量为0且没有底层数组。</p>
</li>
<li><p><strong><code>make</code> 函数创建切片</strong><br><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片:</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">a :&#x3D; make([]int, 5) &#x2F;&#x2F; len(a)&#x3D;5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>要指定它的容量，需向 <code>make</code> 传入第三个参数:</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">b :&#x3D; make([]int, 0, 5) &#x2F;&#x2F; len(b)&#x3D;0, cap(b)&#x3D;5

b &#x3D; b[:cap(b)] &#x2F;&#x2F; len(b)&#x3D;5, cap(b)&#x3D;5
b &#x3D; b[1:]      &#x2F;&#x2F; len(b)&#x3D;4, cap(b)&#x3D;4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>切片的切片</strong></p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">board :&#x3D; [][]string&#123;
    []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,
    []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,
    []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;,
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>追加元素</strong></p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">func append(s []T, vs ...T) []T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</p>
</li>
<li><p><strong><code>for...range</code> 遍历切片</strong><br>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">var pow &#x3D; []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;

func main() &#123;
    for i, v :&#x3D; range pow &#123;
        fmt.Printf(&quot;2**%d &#x3D; %d\n&quot;, i, v)
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以将下标或值赋予 <code>_</code> 来忽略它。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">for i, _ :&#x3D; range pow
for _, value :&#x3D; range pow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>若你只需要索引，忽略第二个变量即可。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">for i :&#x3D; range pow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>映射 (map)</strong><br><code>map</code> 的零值是 <code>nil</code>，不能直接使用，必须通过 <code>make</code> 函数初始化后才能添加键值对。映射的字面量和结构体类似，只不过必须有键名。若顶层类型只是一个类型名，那么你可以在字面量的元素中省略它。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">type Vertex struct &#123;
    Lat, Long float64
&#125;

var m &#x3D; map[string]Vertex&#123;
    &quot;Bell Labs&quot;: Vertex&#123;
        40.68433, -74.39967,
    &#125;,
    &quot;Google&quot;: Vertex&#123;
        37.42202, -122.08408,
    &#125;,
&#125;

&#x2F;&#x2F; 顶层类型省略的写法
var m2 &#x3D; map[string]Vertex&#123;
    &quot;Bell Labs&quot;: &#123;40.68433, -74.39967&#125;,
    &quot;Google&quot;:    &#123;37.42202, -122.08408&#125;,
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>删除映射元素</strong></p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">delete(m, key)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>检测映射键是否存在</strong><br>通过双赋值检测某个键是否存在:</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">elem, ok :&#x3D; m[key]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>若 <code>key</code> 在 <code>m</code> 中，<code>ok</code> 为 <code>true</code>；否则，<code>ok</code> 为 <code>false</code>。若 <code>key</code> 不在映射中，则 <code>elem</code> 是该映射元素类型的零值。</p>
</li>
<li><p><strong>函数值</strong><br>函数可以作为值传递。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">func compute(fn func(float64, float64) float64) float64 &#123;
    return fn(3, 4)
&#125;

func main() &#123;
    hypot :&#x3D; func(x, y float64) float64 &#123;
        return math.Sqrt(x*x + y*y)
    &#125;
    fmt.Println(hypot(5, 12))

    fmt.Println(compute(hypot))
    fmt.Println(compute(math.Pow))
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>函数闭包</strong><br>Go函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，因此在函数被调用时，这些变量是绑定在其上的。</p>
</li>
</ol>
<h2 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h2><ol>
<li><p><strong>方法</strong><br> Go没有类。不过你可以为类型定义方法。方法就是一类带特殊的接收者参数的函数。方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p>
 <pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">type Vertex struct &#123;
    X, Y float64
&#125;

func (v Vertex) Abs() float64 &#123;
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> <code>(v Vertex)</code> 就是这个方法的接收者。通俗来说，这个方法必须是一个实例才能使用。</p>
</li>
<li><p><strong>方法即函数</strong><br> 方法只是个带接收者参数的函数。</p>
</li>
<li><p><strong>接收者类型定义与方法声明</strong><br> 接收者的类型定义和方法声明必须在同一包内。</p>
</li>
<li><p><strong>指针接收者</strong><br> 指针接收者的主要用途是允许方法修改其接收者所指向的底层数据，或者为了性能考虑避免大型结构体的复制。</p>
 <pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">type Vertex struct &#123;
    X, Y float64
&#125;

func (v Vertex) Abs() float64 &#123;
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
&#125;

func (v *Vertex) Scale(f float64) &#123; &#x2F;&#x2F; 指针接收者
    v.X &#x3D; v.X * f
    v.Y &#x3D; v.Y * f
&#125;

func main() &#123;
    v :&#x3D; Vertex&#123;3, 4&#125;
    v.Scale(10) &#x2F;&#x2F; Go会将语句 v.Scale(10) 解释为 (&amp;v).Scale(10)。
    fmt.Println(v.Abs())
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 试着移除第16行 <code>Scale</code> 函数声明中的 <code>*</code>，发现函数的行为就发生了改变（变成值传递）。</p>
</li>
<li><p><strong>接收者为指针的方法调用</strong><br> 接收者为指针的方法被调用时，接收者既能是值又能是指针: Go会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code>。</p>
 <pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">var v Vertex
v.Scale(5)  &#x2F;&#x2F; OK
p :&#x3D; &amp;v
p.Scale(10) &#x2F;&#x2F; OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>以值为接收者的方法调用</strong><br> 以值为接收者的方法被调用时，接收者既能为值又能为指针。</p>
 <pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">var v Vertex
fmt.Println(v.Abs()) &#x2F;&#x2F; OK
p :&#x3D; &amp;v
fmt.Println(p.Abs()) &#x2F;&#x2F; OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p> 这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code>。</p>
</li>
<li><p><strong>接口</strong><br> 接口类型的定义为一组方法签名。接口类型的变量可以持有任何实现了这些方法的值。</p>
 <pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">&#x2F;&#x2F; 定义一个通用接口
type Abser interface &#123;
    Abs() float64
&#125;

&#x2F;&#x2F; 假设有一个 Abser 接口的切片
type MyFloat float64
func (f MyFloat) Abs() float64 &#123; return float64(math.Abs(float64(f))) &#125;

type Vertex struct &#123; X, Y float64 &#125;
func (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y) &#125;

things :&#x3D; []Abser&#123;
    MyFloat(-1.0),
    &amp;Vertex&#123;3, 4&#125;, &#x2F;&#x2F; 注意这里是取地址,因为*Vertex 实现了 Abser
    MyFloat(2.0),
    &amp;Vertex&#123;-1, 0&#125;,
&#125;

&#x2F;&#x2F; 现在你可以用一个循环统一处理所有实现了 Abser 的类型
for _, item :&#x3D; range things &#123;
    fmt.Println(item.Abs()) &#x2F;&#x2F; Go 会根据 item 的实际类型,调用对应的Abs()实现
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>接口实现与接收者类型</strong></p>
<ul>
<li><p>如果方法的接收者是值类型（例如 <code>func (f MyFloat) Abs()</code>），那么值类型和对应的指针类型都实现了接口。</p>
</li>
<li><p>如果方法的接收者是指针类型（例如 <code>func (v *Vertex) Abs()</code>），那么只有指针类型实现了接口。<br>这是因为通过指针可以修改原始值，而通过值传递则不行，Go语言为了避免混淆和潜在的副作用，作出了这样的区分。</p>
</li>
</ul>
</li>
<li><p><strong>隐式接口实现</strong><br> 类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有 <code>implements</code> 关键字。</p>
 <pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">type I interface &#123;
    M()
&#125;

type T struct &#123;
    S string
&#125;

&#x2F;&#x2F; 此方法表示类型 T 实现了接口I,不过我们并不需要显式声明这一点。
func (t T) M() &#123;
    fmt.Println(t.S)
&#125;

func main() &#123;
    var i I &#x3D; T&#123;&quot;hello&quot;&#125;
    i.M()
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>接口值的内部表示</strong><br><code>%T</code> 会显示接口变量内部“包裹”的具体类型，而不是接口类型本身。因为在内部，接口值可以看做包含值和具体类型的元组: <code>(value, type)</code>。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">type F float64

func (f F) M() &#123;
    fmt.Println(f)
&#125;

type I interface &#123;
    M()
&#125;

type T struct &#123;
    S string
&#125;

func (t *T) M() &#123;
    fmt.Println(t.S)
&#125;

func describe(i I) &#123;
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
&#125;

func main() &#123;
    var i I

    i &#x3D; &amp;T&#123;&quot;Hello&quot;&#125;
    describe(i)
    i.M()

    i &#x3D; F(math.Pi)
    describe(i)
    i.M()
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">&#123;</span>Hello<span class="token punctuation">&#125;</span>, *main.T<span class="token punctuation">)</span>
Hello
<span class="token punctuation">(</span><span class="token number">3.141592653589793</span>, main.F<span class="token punctuation">)</span>
<span class="token number">3.141592653589793</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong><code>nil</code> 具体值的接口</strong><br>即便接口内的具体值为 <code>nil</code>，方法仍然会被 <code>nil</code> 接收者调用。保存了 <code>nil</code> 具体值的接口其自身并不为 <code>nil</code>。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">type I interface &#123;
    M()
&#125;

type T struct &#123;
    S string
&#125;

func (t *T) M() &#123;
    if t &#x3D;&#x3D; nil &#123;
        fmt.Println(&quot;&lt;nil&gt;&quot;)
        return
    &#125;
    fmt.Println(t.S)
&#125;

func describe(i I) &#123;
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
&#125;

func main() &#123;
    var i I

    var t *T
    i &#x3D; t
    describe(i)
    i.M()

    i &#x3D; &amp;T&#123;&quot;hello&quot;&#125;
    describe(i)
    i.M()
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span><span class="token operator">&lt;</span>nil<span class="token operator">></span>, *main.T<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>nil<span class="token operator">></span>
<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">&#123;</span>hello<span class="token punctuation">&#125;</span>, *main.T<span class="token punctuation">)</span>
hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>i</code> 一开始的具体值是 <code>nil</code>，但是动态类型是 <code>*T</code>。</p>
</li>
<li><p><strong><code>nil</code> 接口值</strong><br><code>nil</code> 接口值既不保存值也不保存具体类型。为 <code>nil</code> 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个具体方法的类型。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">type I interface &#123;
    M()
&#125;

func describe(i I) &#123;
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
&#125;

func main() &#123;
    var i I
    describe(i)
    i.M() &#x2F;&#x2F; 会产生运行时错误: panic: interface conversion: interface &#123;&#125; is nil, not main.I
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>空接口</strong><br>指定了零个方法的接口值被称为空接口:</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">var i interface&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>空接口可保存任何类型的值。(因为每个类型都至少实现了零个方法。)</p>
</li>
<li><p><strong>空接口的应用</strong><br>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface&#123;&#125;</code> 的任意数量的参数。这个函数实际上传入的是空接口，正是空接口的特性，使其可以传入任何参数。</p>
</li>
<li><p><strong>类型断言</strong><br>类型断言提供了访问接口值底层具体值的方式。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">t :&#x3D; i.(T)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>若并未保存类型 <code>T</code> 的值，该语句就会触发一个 <code>panic</code>。</p>
</li>
<li><p><strong>带 <code>ok</code> 的类型断言</strong><br>为了判断一个接口值是否保存了一个特定的类型，类型断言可返回两个值: 其底层值以及一个报告断言是否成功的布尔值。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">t, ok :&#x3D; i.(T)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">func main() &#123;
    var i interface&#123;&#125; &#x3D; &quot;hello&quot;

    s :&#x3D; i.(string)
    fmt.Println(s)

    s, ok :&#x3D; i.(string)
    fmt.Println(s, ok)

    f, ok :&#x3D; i.(float64)
    fmt.Println(f, ok)

    f &#x3D; i.(float64) &#x2F;&#x2F; panic: interface conversion: interface &#123;&#125; is string, not float64
    fmt.Println(f)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hello
hello <span class="token boolean">true</span>
<span class="token number">0</span> <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>读取映射的规则</strong><br>读取一个映射也有同样的规则（指双赋值检测键是否存在）。</p>
</li>
<li><p><strong>类型选择</strong><br>类型选择是一种按顺序从几个类型断言中选择分支的结构。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">switch v :&#x3D; i.(type) &#123;
case T:
    &#x2F;&#x2F; v 的类型为 T
case S:
    &#x2F;&#x2F; v 的类型为 S
default:
    &#x2F;&#x2F; 没有匹配,v与i的类型相同
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别拥有 <code>T</code> 或 <code>S</code> 类型的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。</p>
</li>
<li><p><strong><code>Stringer</code> 接口</strong><br><code>fmt</code> 包中定义的 <code>Stringer</code> 是最普遍的接口之一。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">type Stringer interface &#123;
    String() string
&#125;
func main() &#123;
    type Person struct &#123;
        Name string
        Age  int
    &#125;

    func (p Person) String() string &#123;
        return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)
    &#125;

    a :&#x3D; Person&#123;&quot;Arthur Dent&quot;, 42&#125;
    z :&#x3D; Person&#123;&quot;Zaphod Beeblebrox&quot;, 9001&#125;
    fmt.Println(a, z)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Arthur Dent <span class="token punctuation">(</span><span class="token number">42</span> years<span class="token punctuation">)</span> Zaphod Beeblebrox <span class="token punctuation">(</span><span class="token number">9001</span> years<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>简而言之就是可以自己实现 <code>Println</code> 出来是长什么样子了，只要给这个数据类型定义一个 <code>String()</code> 方法。</p>
</li>
<li><p><strong>错误 (error)</strong><br>Go 程序使用 <code>error</code> 值来表示错误状态。</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">type error interface &#123;
    Error() string
&#125;
func main() &#123;
    type MyError struct &#123;
        When time.Time
        What string
    &#125;

    func (e MyError) Error() string &#123;
        return fmt.Sprintf(&quot;at %v, %s&quot;, e.When, e.What)
    &#125;

    func run() error &#123;
        return &amp;MyError&#123;
            time.Now(),
            &quot;it didn&#39;t work&quot;,
        &#125;
    &#125;

    if err :&#x3D; run(); err !&#x3D; nil &#123;
        fmt.Println(err)
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">type ErrNegativeSqrt float64

func (e ErrNegativeSqrt) Error() string &#123;
    return fmt.Sprintf(&quot;cannot Sqrt negative number: %v&quot;, float64(e))
&#125;

func Sqrt(x float64) (float64, error) &#123;
    if x &lt; 0 &#123;
        return 0.0, ErrNegativeSqrt(x)
    &#125;
    return math.Sqrt(x), nil
&#125;

func main() &#123;
    fmt.Println(Sqrt(2))
    fmt.Println(Sqrt(-2))
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>为了在函数执行失败时优雅地通知调用者并提供错误详情，我们设计一个能携带上下文信息的自定义类型，通过实现其 <code>Error() string</code> 方法使其成为一个 <code>error</code> 对象，然后在函数失败时返回该对象的实例。</p>
</li>
<li><p><strong><code>io.Reader</code> 接口</strong><br><code>io.Reader</code> 接口有一个 <code>Read</code> 方法:</p>
<pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">func (T) Read(b []byte) (n int, err error)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>Read</code> 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code> 错误。</p>
</li>
</ol>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol>
<li><p><strong>类型参数</strong><br> 可以使用类型参数编写 Go 函数来处理多种类型。函数的类型参数出现在函数参数之前的方括号之间。</p>
 <pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">func Index[T comparable](s []T, x T) int<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> 此声明意味着 <code>s</code> 是满足内置约束 <code>comparable</code> 的任何类型的切片。<code>x</code> 也是相同类型的值。</p>
</li>
<li><p><strong>泛型单链表实现</strong><br> 一个普通的单链表实现 (707.设计链表-力扣 (LeetCode))[<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/]">https://leetcode.cn/problems/design-linked-list/]</a> ：</p>
 <pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">type MyLinkedList struct &#123;
size int
dummyHead *Node
&#125;

type Node struct &#123;
    val int
    next *Node
&#125;

func Constructor() MyLinkedList &#123;
    return MyLinkedList&#123;
        size: 0,
        dummyHead: &amp;Node&#123;&#125;,
    &#125;
&#125;

func (this *MyLinkedList) Get(index int) int &#123;
    if index &gt;&#x3D; this.size &#123;
        return -1
    &#125; 

    p :&#x3D; this.dummyHead
    for index &gt;&#x3D; 0 &#123;
        p &#x3D; p.next
        index--
    &#125;

    return p.val
&#125;

func (this *MyLinkedList) AddAtHead(val int)  &#123;
    this.dummyHead.next &#x3D; &amp;Node&#123;val, this.dummyHead.next&#125;
    this.size++
&#125;

func (this *MyLinkedList) AddAtTail(val int)  &#123;
    p :&#x3D; this.dummyHead
    for p.next !&#x3D; nil &#123;
        p &#x3D; p.next
    &#125;
    p.next &#x3D; &amp;Node&#123;val, nil&#125;
    this.size++
&#125;

func (this *MyLinkedList) AddAtIndex(index int, val int)  &#123;
    if index &gt; this.size &#123;
        return
    &#125;

    if index &#x3D;&#x3D; this.size &#123;
        this.AddAtTail(val)
        return
    &#125;

    if index &#x3D;&#x3D; 0 &#123;
        this.AddAtHead(val)
        return
    &#125;

    p :&#x3D; this.dummyHead
    for index &gt; 0 &#123;
        p &#x3D; p.next
        index--
    &#125;

    p.next &#x3D; &amp;Node&#123;val, p.next&#125;

    this.size++
&#125;

func (this *MyLinkedList) DeleteAtIndex(index int)  &#123;
    if index &gt;&#x3D; this.size &#123;
        return
    &#125;

    p :&#x3D; this.dummyHead
    for index &gt; 0 &#123;
        p &#x3D; p.next
        index--
    &#125;

    p.next &#x3D; p.next.next

    this.size--
&#125;

&#x2F;**
* Your MyLinkedList object will be instantiated and called as such:
* obj :&#x3D; Constructor();
* param_1 :&#x3D; obj.Get(index);
* obj.AddAtHead(val);
* obj.AddAtTail(val);
* obj.AddAtIndex(index,val);
* obj.DeleteAtIndex(index);
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 运用了泛型类型:</p>
 <pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">type MyLinkedList[T any] struct &#123;
    size      int
    dummyHead *Node[T]
&#125;

type Node[T any] struct &#123;
    val  T
    next *Node[T]
&#125;

func Constructor[T any]() *MyLinkedList[T] &#123;
    return &amp;MyLinkedList[T]&#123;
        size:      0,
        dummyHead: &amp;Node[T]&#123;&#125;,
    &#125;
&#125;

func (this *MyLinkedList[T]) Get(index int) (T, bool) &#123;
    var zeroval T
    if index &gt;&#x3D; this.size &#123;
        return zeroval, false
    &#125;

    p :&#x3D; this.dummyHead
    for index &gt;&#x3D; 0 &#123;
        p &#x3D; p.next
        index--
    &#125;

    return p.val, true
&#125;

func (this *MyLinkedList[T]) AddAtHead(val T) &#123;
    this.dummyHead.next &#x3D; &amp;Node[T]&#123;val, this.dummyHead.next&#125;
    this.size++
&#125;

func (this *MyLinkedList[T]) AddAtTail(val T) &#123;
    p :&#x3D; this.dummyHead
    for p.next !&#x3D; nil &#123;
        p &#x3D; p.next
    &#125;
    p.next &#x3D; &amp;Node[T]&#123;val, nil&#125;
    this.size++
&#125;

func (this *MyLinkedList[T]) AddAtIndex(index int, val T) &#123;
    if index &gt; this.size &#123;
        return
    &#125;

    if index &#x3D;&#x3D; this.size &#123;
        this.AddAtTail(val)
        return
    &#125;

    if index &#x3D;&#x3D; 0 &#123;
        this.AddAtHead(val)
        return
    &#125;

    p :&#x3D; this.dummyHead
    for index &gt; 0 &#123;
        p &#x3D; p.next
        index--
    &#125;

    p.next &#x3D; &amp;Node[T]&#123;val, p.next&#125;
    this.size++
&#125;

func (this *MyLinkedList[T]) DeleteAtIndex(index int) &#123;
    if index &gt;&#x3D; this.size &#123;
        return
    &#125;

    p :&#x3D; this.dummyHead
    for index &gt; 0 &#123;
        p &#x3D; p.next
        index--
    &#125;

    p.next &#x3D; p.next.next
    this.size--
&#125;

&#x2F;**
 * Your MyLinkedList object will be instantiated and called as such:
 * obj :&#x3D; Constructor();
 * param_1 :&#x3D; obj.Get(index);
 * obj.AddAtHead(val);
 * obj.AddAtTail(val);
 * obj.AddAtIndex(index, val);
 * obj.DeleteAtIndex(index);
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ol>
<li><p><strong>Go程 (goroutine)</strong><br> Go程（<code>goroutine</code>）是由Go运行时管理的轻量级线程。</p>
 <pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">go f(x, y, z)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> 会启动一个新的Go协程并执行 <code>f(x, y, z)</code>。<code>f, x, y</code> 和 <code>z</code> 的求值发生在当前的Go协程中，而 <code>f</code> 的执行发生在新的Go协程中。</p>
 <pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">func say(s string) &#123;
    for i :&#x3D; 0; i &lt; 5; i++ &#123;
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    &#125;
&#125;

func main() &#123;
    go say(&quot;world&quot;)
    say(&quot;hello&quot;)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 结果 <strong>unpredictable</strong></p>
</li>
</ol>

  </div>
</mdui-card>
<script>
  const $ = mdui.$;
  $("#post-all").find("img").each((index, ele) => {
    $(ele).replaceWith(`<a data-src="${$(ele).prop("src")}" class="fancybox-enabled" data-fancybox="picture" data-caption="${$(ele).prop("alt")}">${ele.outerHTML}</a>`)
  });
  Fancybox.bind(".fancybox-enabled", {
    on: {
      ready: () => {
        $("mdui-top-app-bar").addClass("invisible")
      }, close: () => {
        $("mdui-top-app-bar").removeClass("invisible")
      }
    }
  });
  
</script>

    
                    
              <br>
              <span>© 2025 Eagle233 <br>Powered By Hexo & Theme mdsuper</span>
          </div>
        </mdui-layout-main>
    </mdui-layout>
    <script>const searchxml_url = "/search.xml";</script>

<script src="/js/mdsuper-search.js"></script>

    <mdui-dialog close-on-overlay-click close-on-esc fullscreen id="search-dlg">
        <mdui-top-app-bar slot="header" style="padding: 32px;">
            <mdui-top-app-bar-title>
                Search
            </mdui-top-app-bar-title>
            <mdui-button-icon icon="close" id="search-dlg-close"></mdui-button-icon>
        </mdui-top-app-bar>
        <mdui-text-field icon="search" label='Search' id="search-input"></mdui-text-field>
        <mdui-list id="search-res-list">
        </mdui-list>
    </mdui-dialog>
    <script>
        $("#search-dlg-close").on("click", function () {
            $("#search-dlg").get(0).open = false;
        });
        $("#search-input").get(0).addEventListener('input', function () {
            let val = $(this).val().toLowerCase();
            $("#search-res-list").html("");
            if (!val) return;
            let keywords = val.split(" ").filter((x)=>x.length>=2);
            let searchRes = search(keywords);
            searchRes.forEach((dat) => {
                $("#search-res-list").append(`<mdui-list-item href="${dat.url}" rounded headline-line="1" description-line="3">
          ${highlightSearch(dat.title, keywords)}
          <span slot="description">${highlightSearch(dat.content, keywords)}</span>
        </mdui-list-item>`);
            })
        })
    </script>
        
          <script>
            mdui.setColorScheme('#3f51b5');
            const navigationDrawer = document.querySelector("#drawer");
            const mainlayout = document.querySelector("#main");
            const breakpointCondition = mdui.breakpoint();
            if (breakpointCondition.up('sm')) {
              if (localStorage.getItem('navigationDrawer') == null) {
                if("true"=="true")localStorage.setItem('navigationDrawer', "true");
              }
              if("true"=="true")navigationDrawer.setAttribute("open", (localStorage.getItem('navigationDrawer') == "true" ? true : false))
            }
            const menuBtn = document.querySelector("#menu-btn");
            menuBtn.addEventListener("click", () => {
              navigationDrawer.open = !navigationDrawer.open;
              if("true"=="true")localStorage.setItem('navigationDrawer', navigationDrawer.open.toString());
            });
            const searchBtn = document.querySelector("#search-dlg-btn");
            searchBtn.addEventListener("click", () => {
              document.querySelector("#search-dlg").open = true;
            });
          </script>
          
<script src="/js/prism.js"></script>

  </body>

</html>