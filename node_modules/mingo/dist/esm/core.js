import {
  assert,
  has,
  isArray,
  isFunction,
  isNil,
  isObject,
  isObjectLike,
  isOperator,
  isString,
  resolve
} from "./util";
var ProcessingMode = /* @__PURE__ */ ((ProcessingMode2) => {
  ProcessingMode2["CLONE_ALL"] = "CLONE_ALL";
  ProcessingMode2["CLONE_INPUT"] = "CLONE_INPUT";
  ProcessingMode2["CLONE_OUTPUT"] = "CLONE_OUTPUT";
  ProcessingMode2["CLONE_OFF"] = "CLONE_OFF";
  return ProcessingMode2;
})(ProcessingMode || {});
class ComputeOptions {
  #options;
  /** Reference to the root object when processing subgraphs of the object. */
  #root;
  #local;
  constructor(options, root, local) {
    this.#options = options;
    this.update(root, local);
  }
  /**
   * Initialize new ComputeOptions.
   *
   * @param options
   * @param root
   * @param local
   * @returns {ComputeOptions}
   */
  static init(options, root, local) {
    return options instanceof ComputeOptions ? new ComputeOptions(options.#options, options.root ?? root, {
      ...options.#local,
      ...local,
      // retain existing variables
      variables: Object.assign(
        {},
        options.#local?.variables,
        local?.variables
      )
    }) : new ComputeOptions(options, root, local);
  }
  /**
   * Updates the internal state.
   *
   * @param root The new root context for this object.
   * @param local The new local state to merge into current if it exists.
   * @returns
   */
  update(root, local) {
    this.#root = root;
    const variables = Object.assign(
      {},
      this.#local?.variables,
      local?.variables
    );
    if (Object.keys(variables).length) {
      this.#local = { ...local, variables };
    } else {
      this.#local = local ?? {};
    }
    return this;
  }
  getOptions() {
    return Object.freeze({
      ...this.#options,
      context: Context.from(this.#options.context)
    });
  }
  get root() {
    return this.#root;
  }
  get local() {
    return this.#local;
  }
  get idKey() {
    return this.#options.idKey;
  }
  get collation() {
    return this.#options?.collation;
  }
  get processingMode() {
    return this.#options?.processingMode || "CLONE_OFF" /* CLONE_OFF */;
  }
  get useStrictMode() {
    return this.#options?.useStrictMode;
  }
  get scriptEnabled() {
    return this.#options?.scriptEnabled;
  }
  get useGlobalContext() {
    return this.#options?.useGlobalContext;
  }
  get hashFunction() {
    return this.#options?.hashFunction;
  }
  get collectionResolver() {
    return this.#options?.collectionResolver;
  }
  get jsonSchemaValidator() {
    return this.#options?.jsonSchemaValidator;
  }
  get variables() {
    return this.#options?.variables;
  }
  get context() {
    return this.#options?.context;
  }
}
function initOptions(options) {
  return options instanceof ComputeOptions ? options.getOptions() : Object.freeze({
    idKey: "_id",
    scriptEnabled: true,
    useStrictMode: true,
    useGlobalContext: true,
    processingMode: "CLONE_OFF" /* CLONE_OFF */,
    ...options,
    context: options?.context ? Context.from(options?.context) : Context.init({})
  });
}
var OperatorType = /* @__PURE__ */ ((OperatorType2) => {
  OperatorType2["ACCUMULATOR"] = "accumulator";
  OperatorType2["EXPRESSION"] = "expression";
  OperatorType2["PIPELINE"] = "pipeline";
  OperatorType2["PROJECTION"] = "projection";
  OperatorType2["QUERY"] = "query";
  OperatorType2["WINDOW"] = "window";
  return OperatorType2;
})(OperatorType || {});
class Context {
  constructor(ops) {
    this.operators = {
      ["accumulator" /* ACCUMULATOR */]: {},
      ["expression" /* EXPRESSION */]: {},
      ["pipeline" /* PIPELINE */]: {},
      ["projection" /* PROJECTION */]: {},
      ["query" /* QUERY */]: {},
      ["window" /* WINDOW */]: {}
    };
    for (const [type, operators] of Object.entries(ops)) {
      this.addOperators(type, operators);
    }
  }
  static init(ops = {}) {
    return new Context(ops);
  }
  static from(ctx) {
    return new Context(ctx.operators);
  }
  addOperators(type, ops) {
    for (const [name, fn] of Object.entries(ops)) {
      if (!this.getOperator(type, name)) {
        this.operators[type][name] = fn;
      }
    }
    return this;
  }
  // register
  addAccumulatorOps(ops) {
    return this.addOperators("accumulator" /* ACCUMULATOR */, ops);
  }
  addExpressionOps(ops) {
    return this.addOperators("expression" /* EXPRESSION */, ops);
  }
  addQueryOps(ops) {
    return this.addOperators("query" /* QUERY */, ops);
  }
  addPipelineOps(ops) {
    return this.addOperators("pipeline" /* PIPELINE */, ops);
  }
  addProjectionOps(ops) {
    return this.addOperators("projection" /* PROJECTION */, ops);
  }
  addWindowOps(ops) {
    return this.addOperators("window" /* WINDOW */, ops);
  }
  // getters
  getOperator(type, name) {
    return type in this.operators ? this.operators[type][name] || null : null;
  }
}
const GLOBAL_CONTEXT = Context.init();
function useOperators(type, operators) {
  for (const [name, fn] of Object.entries(operators)) {
    assert(
      isFunction(fn) && isOperator(name),
      `'${name}' is not a valid operator`
    );
    const currentFn = getOperator(type, name, null);
    assert(
      !currentFn || fn === currentFn,
      `${name} already exists for '${type}' operators. Cannot change operator function once registered.`
    );
  }
  switch (type) {
    case "accumulator" /* ACCUMULATOR */:
      GLOBAL_CONTEXT.addAccumulatorOps(operators);
      break;
    case "expression" /* EXPRESSION */:
      GLOBAL_CONTEXT.addExpressionOps(operators);
      break;
    case "pipeline" /* PIPELINE */:
      GLOBAL_CONTEXT.addPipelineOps(operators);
      break;
    case "projection" /* PROJECTION */:
      GLOBAL_CONTEXT.addProjectionOps(operators);
      break;
    case "query" /* QUERY */:
      GLOBAL_CONTEXT.addQueryOps(operators);
      break;
    case "window" /* WINDOW */:
      GLOBAL_CONTEXT.addWindowOps(operators);
      break;
  }
}
function getOperator(type, operator, options) {
  const { context: ctx, useGlobalContext: fallback } = options || {};
  const fn = ctx ? ctx.getOperator(type, operator) : null;
  return !fn && fallback ? GLOBAL_CONTEXT.getOperator(type, operator) : fn;
}
const systemVariables = {
  $$ROOT(_obj, _expr, options) {
    return options.root;
  },
  $$CURRENT(obj, _expr, _options) {
    return obj;
  },
  $$REMOVE(_obj, _expr, _options) {
    return void 0;
  },
  $$NOW(_obj, _expr, options) {
    return /* @__PURE__ */ new Date();
  }
};
const redactVariables = {
  $$KEEP(obj, _expr, _options) {
    return obj;
  },
  $$PRUNE(_obj, _expr, _options) {
    return void 0;
  },
  $$DESCEND(obj, expr, options) {
    if (!has(expr, "$cond")) return obj;
    let result;
    for (const [key, current] of Object.entries(obj)) {
      if (isObjectLike(current)) {
        if (isArray(current)) {
          const array = [];
          for (let elem of current) {
            if (isObject(elem)) {
              elem = redact(elem, expr, options.update(elem));
            }
            if (!isNil(elem)) {
              array.push(elem);
            }
          }
          result = array;
        } else {
          result = redact(
            current,
            expr,
            options.update(current)
          );
        }
        if (isNil(result)) {
          delete obj[key];
        } else {
          obj[key] = result;
        }
      }
    }
    return obj;
  }
};
function computeValue(obj, expr, operator, options) {
  const copts = ComputeOptions.init(options, obj);
  return !!operator && isOperator(operator) ? computeOperator(obj, expr, operator, copts) : computeExpression(obj, expr, copts);
}
function computeExpression(obj, expr, options) {
  if (isString(expr) && expr.length > 0 && expr[0] === "$") {
    if (has(redactVariables, expr)) return expr;
    let ctx = options.root;
    const arr = expr.split(".");
    if (has(systemVariables, arr[0])) {
      ctx = systemVariables[arr[0]](
        obj,
        null,
        options
      );
      expr = expr.slice(arr[0].length + 1);
    } else if (arr[0].slice(0, 2) === "$$") {
      ctx = Object.assign(
        {},
        // global vars
        options.variables,
        // current item is added before local variables because the binding may be changed.
        { this: obj },
        // local vars
        options?.local?.variables
      );
      const name = arr[0].slice(2);
      assert(has(ctx, name), `Use of undefined variable: ${name}`);
      expr = expr.slice(2);
    } else {
      expr = expr.slice(1);
    }
    return expr === "" ? ctx : resolve(ctx, expr);
  }
  if (isArray(expr)) {
    return expr.map((item) => computeExpression(obj, item, options));
  }
  if (isObject(expr)) {
    const result = {};
    const elems = Object.entries(expr);
    for (const [key, val] of elems) {
      if (isOperator(key)) {
        assert(elems.length == 1, "expression must have single operator.");
        return computeOperator(obj, val, key, options);
      }
      result[key] = computeExpression(obj, val, options);
    }
    return result;
  }
  return expr;
}
function computeOperator(obj, expr, operator, options) {
  const callExpression = getOperator(
    "expression" /* EXPRESSION */,
    operator,
    options
  );
  if (callExpression) return callExpression(obj, expr, options);
  const callAccumulator = getOperator(
    "accumulator" /* ACCUMULATOR */,
    operator,
    options
  );
  assert(!!callAccumulator, `accumulator '${operator}' is not registered.`);
  if (!isArray(obj)) {
    obj = computeExpression(obj, expr, options);
    expr = null;
  }
  assert(isArray(obj), `arguments must resolve to array for ${operator}.`);
  return callAccumulator(
    obj,
    expr,
    options.update(null, options.local)
    // reset the root object.
  );
}
function redact(obj, expr, options) {
  const result = computeExpression(obj, expr, options);
  return has(redactVariables, result) ? redactVariables[result](obj, expr, options) : result;
}
export {
  ComputeOptions,
  Context,
  OperatorType,
  ProcessingMode,
  computeValue,
  getOperator,
  initOptions,
  redact,
  useOperators
};
